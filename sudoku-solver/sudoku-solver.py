class Solution:\u000A    def solveSudoku(self, board: List[List[str]]) \u002D\u003E None:\u000A        \u0022\u0022\u0022\u000A        Do not return anything, modify board in\u002Dplace instead.\u000A        \u0022\u0022\u0022\u000A        def checkBit(musk: int, pos: int) \u002D\u003E bool:\u000A            if (musk \u0026 (1\u003C\u003Cpos)):\u000A                return True\u000A            return False\u000A        \u000A        def setBit(musk:int, pos:int) \u002D\u003E int:\u000A            return (musk | (1 \u003C\u003C pos))\u000A        \u000A        def unSetBit(musk:int , pos:int ) \u002D\u003Eint:\u000A            return (musk ^ (1\u003C\u003Cpos))\u000A        \u000A        def backTrack(i:int, j:int, musk: List[List[int]], muskRowCol: List[int]) \u002D\u003E bool:\u000A            if i \u003D\u003D 9:\u000A                return True\u000A            \u000A            if j \u003D\u003D 9:\u000A                return backTrack(i + 1, 0, musk, muskRowCol)\u000A            \u000A            value \u003D board[i][j]\u000A            if board[i][j].isnumeric():\u000A                digit \u003D int(value) \u002D 1\u000A                \u000A                if backTrack(i, j + 1, musk, muskRowCol):\u000A                        return True\u000A                    \u000A                return False\u000A            \u000A            for digit in range(9):\u000A                if not checkBit(muskRowCol[0][i], digit) and not checkBit(muskRowCol[1][j], digit) and not checkBit(musk[i//3][j//3], digit):\u000A                    muskRowCol[0][i] \u003D setBit(muskRowCol[0][i], digit)\u000A                    muskRowCol[1][j] \u003D setBit(muskRowCol[1][j], digit)\u000A                    musk[i//3][j//3] \u003D setBit(musk[i//3][j//3], digit)\u000A                    board[i][j] \u003D str(digit + 1)\u000A                    if backTrack(i, j + 1, musk, muskRowCol):\u000A                         return True\u000A                    muskRowCol[0][i] \u003D unSetBit(muskRowCol[0][i], digit)\u000A                    muskRowCol[1][j] \u003D unSetBit(muskRowCol[1][j], digit)\u000A                    musk[i//3][j//3] \u003D unSetBit(musk[i//3][j//3], digit)\u000A                    \u000A            board[i][j] \u003D value \u000A            return False\u000A\u000A        musk \u003D [[0] *3 for i in range(3)]\u000A        muskRowCol \u003D [[0] * 10  for i in range(2)]\u000A        \u000A        for i in range(9):\u000A            for j in range(9):\u000A                if board[i][j].isnumeric():\u000A                    digit \u003D int(board[i][j]) \u002D 1\u000A                    muskRowCol[0][i] \u003D setBit(muskRowCol[0][i], digit)\u000A                    muskRowCol[1][j] \u003D setBit(muskRowCol[1][j], digit)\u000A                    musk[i//3][j//3] \u003D setBit(musk[i//3][j//3], digit)\u000A        \u000A        backTrack(0, 0, musk, muskRowCol)\u000A